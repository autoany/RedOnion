using Bee.Run;
using System;
using System.Text;
using System.Globalization;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace Bee
{
	/// <summary>
	/// Pseudo Generator leaves literals in string form and uses @pseudoBlock
	/// </summary>
	public partial class PseudoGenerator: Parser.IGenerator
	{
		/// <summary>
		/// code block header (generated by pseudo code generator)
		/// </summary>
		public struct PseudoBlock
		{
			/// <summary>
			/// number of statements
			/// </summary>
			public int Count;
			/// <summary>
			/// size of code
			/// </summary>
			public int Size;
		}
		
		/// <summary>
		/// code block header (generated by compressing code generator)
		/// </summary>
		public struct PressBlock
		{
			/// <summary>
			/// size of code
			/// </summary>
			public int Size;
		}
		
		/// <summary>
		/// class header
		/// </summary>
		public struct ClassHeader
		{
			/// <summary>
			/// opcode.class, struct, enum or face
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
			/// <summary>
			/// access and scope flags
			/// </summary>
			public Tflag Flags;
			/// <summary>
			/// number of generic type parameters
			/// </summary>
			public byte Gtnum;
			/// <summary>
			/// number of base classes (including interfaces)
			/// </summary>
			public byte Bcnum;
			/// <summary>
			/// name size (number of bytes)
			/// </summary>
			public byte Namesz;
		}
		
		/// <summary>
		/// field / event header
		/// </summary>
		public struct FieldHeader
		{
			/// <summary>
			/// opcode.field or event
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
			/// <summary>
			/// access and scope flags
			/// </summary>
			public Tflag Flags;
			/// <summary>
			/// name size (number of bytes)
			/// </summary>
			public byte Namesz;
		}
		
		/// <summary>
		/// function/method header
		/// </summary>
		public struct FuncHeader
		{
			/// <summary>
			/// opcode.func
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
			/// <summary>
			/// access and scope flags
			/// </summary>
			public Tflag Flags;
			/// <summary>
			/// number of generic type parameters
			/// </summary>
			public byte Gtnum;
			/// <summary>
			/// number of arguments
			/// </summary>
			public byte Argc;
			/// <summary>
			/// name size (number of bytes)
			/// </summary>
			public byte Namesz;
		}
		
		/// <summary>
		/// property (member group) header
		/// </summary>
		public struct PropHeader
		{
			/// <summary>
			/// opcode.prop
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
			/// <summary>
			/// access and scope flags
			/// </summary>
			public Tflag Flags;
			/// <summary>
			/// number of generic type parameters
			/// </summary>
			public byte Gtnum;
			/// <summary>
			/// number of arguments
			/// </summary>
			public byte Argc;
			/// <summary>
			/// name size (number of bytes)
			/// </summary>
			public byte Namesz;
		}
		
		/// <summary>
		/// field / event header
		/// </summary>
		public struct PropFieldHeader
		{
			/// <summary>
			/// zero (opcode.prop >> 8)
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
		}
		
		/// <summary>
		/// function/method header
		/// </summary>
		public struct PropFuncHeader
		{
			/// <summary>
			/// 1-4 (opcode.get/set/add/remove >> 8)
			/// </summary>
			public byte Code;
			/// <summary>
			/// header size
			/// </summary>
			public int Hsize;
			/// <summary>
			/// access and scope flags
			/// </summary>
			public Tflag Flags;
		}
		
		int Parser.IGenerator.BlockStart()
		{
			Write(0);
			Write(0);
			return CodeAt;
		}
		
		void Parser.IGenerator.BlockEnd(int @int, int count)
		{
			Write(count, @int - 8);
			Write(CodeAt - @int, @int - 4);
		}
		
		int Parser.IGenerator.ExprStart()
		{
			return ValsAt;
		}
		
		void Parser.IGenerator.ExprEnd(int @int)
		{
			if (@int >= ValsAt)
			{
				Debug.Assert(@int == ValsAt);
				Write(unchecked((byte)Opcode.Undef));
			}
			else
			{
				Rewrite(ValsAt);
				ValsAt = @int;
			}
		}
		
		int Parser.IGenerator.TypeStart()
		{
			return ValsAt;
		}
		
		void Parser.IGenerator.TypeEnd(int @int)
		{
			if (@int >= ValsAt)
			{
				Debug.Assert(@int == ValsAt);
				Write(unchecked((byte)Opcode.Undef));
			}
			else
			{
				Rewrite(ValsAt, true);
				ValsAt = @int;
			}
		}
		
		int Parser.IGenerator.Write(Opcode opcode)
		{
			var at = CodeAt;
			Write(unchecked((byte)opcode));
			return at;
		}
		
		void Parser.IGenerator.Write(Opcode op, int @int)
		{
			Debug.Assert(op == Opcode.Dountil || op == Opcode.Foreach);
			Code[@int] = unchecked((byte)op);
		}
		
		void Parser.IGenerator.Ident(string @string)
		{
			Debug.Assert(@string.Length <= 127);
			Write(unchecked((byte)@string.Length));
			Write(@string);
		}
		
		void Parser.IGenerator.Ident(Opcode opcode, string @string)
		{
			Debug.Assert(@string.Length <= 127);
			Write(unchecked((byte)opcode));
			Write(unchecked((byte)@string.Length));
			Write(@string);
		}
		
		int Parser.IGenerator.ClassStart(string name)
		{
			Debug.Assert(name.Length <= 127);
			Write(unchecked((byte)0));
			Write(0);
			var at = CodeAt;
			Write((ushort)0);
			Write(unchecked((byte)0));
			Write(unchecked((byte)0));
			Write(unchecked((byte)name.Length));
			Write(name);
			return at;
		}
		
		int Parser.IGenerator.ClassBody(int @int, string name, Opcode opcode, int gtnum, int bcnum, Tflag tflag)
		{
			Debug.Assert(bcnum <= 127);
			Write(unchecked((byte)opcode), @int - 5);
			Write(CodeAt - @int, @int - 4);
			Write((ushort)tflag, @int);
			Write(unchecked((byte)gtnum), @int + 2);
			Write(unchecked((byte)bcnum), @int + 3);
			Write(0);
			return CodeAt;
		}
		
		void Parser.IGenerator.ClassEnd(int @int, string name)
		{
			Write(CodeAt - @int, @int - 4);
		}
		
		int Parser.IGenerator.FieldStart(string name)
		{
			Debug.Assert(name.Length <= 127);
			Write(unchecked((byte)Opcode.Field));
			Write(0);
			var at = CodeAt;
			Write((ushort)0);
			Write(unchecked((byte)name.Length));
			Write(name);
			return at;
		}
		
		void Parser.IGenerator.FieldEnd(int @int, string name, Opcode type, Tflag tflag)
		{
			if (type != Opcode.Field)
			{
				Debug.Assert(type == Opcode.Event);
				Write(unchecked((byte)type), @int - 5);
			}
			Write(CodeAt - @int, @int - 4);
			Write((ushort)tflag, @int);
		}
		
		int Parser.IGenerator.FuncStart(string fname)
		{
			Debug.Assert(fname.Length <= 127);
			Write(unchecked((byte)Opcode.Func));
			Write(0);
			var at = CodeAt;
			Write((ushort)0);
			Write(unchecked((byte)0));
			Write(unchecked((byte)0));
			Write(unchecked((byte)fname.Length));
			Write(fname);
			Write(0);
			return at;
		}
		
		int Parser.IGenerator.FuncTypeEnd(int @int, string fname)
		{
			var nat = @int + 4;
			var tat = (nat + Code[nat]) + 5;
			Write(CodeAt - tat, tat - 4);
			return @int;
		}
		
		int Parser.IGenerator.FuncArg(int @int, string fname, int index, string aname)
		{
			Write(0);
			var at = CodeAt;
			Write(unchecked((byte)aname.Length));
			Write(aname);
			Write(0);
			return at;
		}
		
		int Parser.IGenerator.FuncArgDef(int fn, int arg, string fname, int index, string aname)
		{
			var @int = (arg + Code[arg]) + 5;
			Write(CodeAt - @int, @int - 4);
			Write(0);
			return arg;
		}
		
		void Parser.IGenerator.FuncArgEnd(int fn, int arg, string fname, int index, string aname)
		{
			var @int = (arg + Code[arg]) + 1;
			@int += 8 + Bits.Int(Code, @int);
			Write(CodeAt - @int, @int - 4);
			Write(CodeAt - arg, arg - 4);
		}
		
		int Parser.IGenerator.FuncBody(int @int, string fname, int argc, Tflag tflag)
		{
			Debug.Assert(argc <= 127);
			Write(CodeAt - @int, @int - 4);
			Write((ushort)tflag, @int);
			Write(unchecked((byte)argc), @int + 3);
			Write(0);
			return CodeAt;
		}
		
		void Parser.IGenerator.FuncEnd(int @int, string fname)
		{
			Write(CodeAt - @int, @int - 4);
		}
		
		int Parser.IGenerator.Func2prop(int @int, string pname)
		{
			Write(unchecked((byte)Opcode.Prop), @int - 5);
			return @int;
		}
		
		int Parser.IGenerator.PropFieldStart(int @int, string pname)
		{
			Write(unchecked((byte)0));
			Write(0);
			var at = CodeAt;
			return at;
		}
		
		void Parser.IGenerator.PropFieldEnd(int pm, int @int, string pname)
		{
			Write(CodeAt - @int, @int - 4);
		}
		
		int Parser.IGenerator.PropFuncStart(int @int, string pname, Opcode kind)
		{
			Write(unchecked((byte)(((ushort)kind) >> 8)));
			Write(0);
			var at = CodeAt;
			Write((ushort)0);
			return at;
		}
		
		int Parser.IGenerator.PropFuncBody(int pm, int @int, string pname, Opcode kind, Tflag tflag)
		{
			Write(CodeAt - @int, @int - 4);
			Write((ushort)tflag, @int);
			Write(0);
			return CodeAt;
		}
		
		void Parser.IGenerator.PropFuncEnd(int pm, int @int, string pname, Opcode kind)
		{
			Write(CodeAt - @int, @int - 4);
		}
		
		void Parser.IGenerator.PropEnd(int @int, string pname)
		{
			Write(CodeAt - @int, @int - 4);
		}
	}
}
