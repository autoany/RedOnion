use bee.run, sys: text, lang, cols.gen, diag, io
pkg bee

@@ Pseudo Generator leaves literals in string form and uses @pseudoBlock
def pseudoGenerator parser.iGenerator partial

	@@ code block header (generated by pseudo code generator)
	def pseudoBlock struct
	public:
		var count	int		@@ number of statements
		var size	int		@@ size of code
	@@ code block header (generated by compressing code generator)
	def pressBlock struct
	public:
		var size	int		@@ size of code
	@@ class header
	def classHeader struct
	public:
		var code	byte	@@ opcode.class, struct, enum or face
		var hsize	int		@@ header size
		var flags	tflag	@@ access and scope flags
		var gtnum	byte	@@ number of generic type parameters
		var bcnum	byte	@@ number of base classes (including interfaces)
		var namesz	byte	@@ name size (number of bytes)
		//  name	char[]
		//	meta	byte[]	// attributes, comments etc.
		//	size	uint
		//	members	byte[]
	@@ field / event header
	def fieldHeader struct
	public:
		var code	byte	@@ opcode.field or event
		var hsize	int		@@ header size
		var flags	tflag	@@ access and scope flags
		var namesz	byte	@@ name size (number of bytes)
		//	name	char[]
		//	meta	byte[]	// attributes, comments etc.
		//	type	byte[]
		//	init	byte[]
	@@ function/method header
	def funcHeader struct
	public:
		var code	byte	@@ opcode.func
		var hsize	int		@@ header size
		var flags	tflag 	@@ access and scope flags
		var gtnum	byte	@@ number of generic type parameters
		var argc	byte	@@ number of arguments
		var namesz	byte	@@ name size (number of bytes)
		//	name	char[]
		//	meta	byte[]	// attributes, comments etc.
		//	type	byte[]
		//	args	byte[]
		//	body	byte[]
	@@ property (member group) header
	def propHeader struct
	public:
		var code	byte	@@ opcode.prop
		var hsize	int		@@ header size
		var flags	tflag	@@ access and scope flags
		var gtnum	byte	@@ number of generic type parameters
		var argc	byte	@@ number of arguments
		var namesz	byte	@@ name size (number of bytes)
		//	name	char[]
		//	meta	byte[]	// attributes, comments etc.
		//	type	byte[]
		//	args	byte[]
		//	subs	byte[]
	@@ field / event header
	def propFieldHeader struct
	public:
		var code	byte	@@ zero (opcode.prop >> 8)
		var hsize	int		@@ header size
		//	meta	byte[]	// attributes, comments etc.
		//	init	byte[]
	@@ function/method header
	def propFuncHeader struct
	public:
		var code	byte	@@ 1-4 (opcode.get/set/add/remove >> 8)
		var hsize	int		@@ header size
		var flags	tflag 	@@ access and scope flags
		//	meta	byte[]	// attributes, comments etc.
		//	body	byte[]

//--------------------------------------------------------------------------------------------------

	parser.iGenerator.blockStart int
		write 0 // count - used in source generator to recognise e.g. `else if`
		write 0 // size
		return codeAt
	parser.iGenerator.blockEnd, int, count int
		write count,		int-8
		write codeAt-int,	int-4

	parser.iGenerator.exprStart int
		return valsAt
	parser.iGenerator.exprEnd, int
		if int >= valsAt
			debug.assert int == valsAt
			write byte! opcode.undef
		else
			rewrite valsAt
			valsAt = int

	parser.iGenerator.typeStart int
		return valsAt
	parser.iGenerator.typeEnd, int
		if int >= valsAt
			debug.assert int == valsAt
			write byte! opcode.undef
		else
			rewrite valsAt, true
			valsAt = int

	parser.iGenerator.write int, opcode
		var at = codeAt
		write byte! opcode
		return at
	parser.iGenerator.write, op opcode, int
		debug.assert \
			op == opcode.dountil ||
			op == opcode.foreach
		code[int] = byte! op

	parser.iGenerator.ident, string
		debug.assert string.length <= 127
		write byte! string.length
		write string
	parser.iGenerator.ident, opcode, string
		debug.assert string.length <= 127
		write byte! opcode
		write byte! string.length
		write string

//--------------------------------------------------------------------------------------------------

	parser.iGenerator.classStart int, name string
		debug.assert name.length <= 127
		write byte! 0		// opcode
		write 0				// header size
		var at = codeAt
		write ushort! 0		// tflag
		write byte! 0		// number of generic parameters
		write byte! 0		// number of base classes and interfaces
		write byte! name.length
		write name
		return at
	parser.iGenerator.classBody int, int, name string, opcode, gtnum int, bcnum int, tflag
		debug.assert bcnum <= 127
		write byte! opcode,		int-5
		write codeAt-int,		int-4
		write ushort! tflag,	int
		write byte! gtnum,		int+2
		write byte! bcnum,		int+3
		write 0				// body size
		return codeAt
	parser.iGenerator.classEnd, int, name string
		write codeAt-int, int-4

//--------------------------------------------------------------------------------------------------

	parser.iGenerator.fieldStart int, name string
		debug.assert name.length <= 127
		write byte! opcode.field
		write 0				// size
		var at = codeAt
		write ushort! 0		// tflag
		write byte! name.length
		write name
		return at
	parser.iGenerator.fieldEnd, int, name string, type opcode, tflag
		if type != opcode.field
			debug.assert type == opcode.event
			write byte! type,	int-5
		write codeAt-int,		int-4
		write ushort! tflag,	int

//--------------------------------------------------------------------------------------------------

	parser.iGenerator.funcStart int, fname string
		debug.assert fname.length <= 127
		write byte! opcode.func
		write 0				// header size
		var at = codeAt
		write ushort! 0		// tflag
		write byte! 0		// number of generic parameters
		write byte! 0		// number of arguments
		write byte! fname.length
		write fname
		write 0				// type size
		return at
	parser.iGenerator.funcTypeEnd int, int, fname string
		var nat = int + 4
		var tat = nat + code[nat] + 5
		write codeAt-tat,		tat-4
		return int
	parser.iGenerator.funcArg int, int, fname string, index int, aname string
		write 0				// argument size
		var at = codeAt
		write byte! aname.length
		write aname
		write 0				// type size
		return at
	parser.iGenerator.funcArgDef int, fn int, arg int, fname string, index int, aname string
		var int = arg + code[arg] + 5
		write codeAt-int,		int-4
		write 0				// value size
		return arg
	parser.iGenerator.funcArgEnd, fn int, arg int, fname string, index int, aname string
		var int = arg + code[arg] + 1
		int += 8 + bits.int code, int
		write codeAt-int,		int-4
		write codeAt-arg,		arg-4
	parser.iGenerator.funcBody int, int, fname string, argc int, tflag
		debug.assert argc <= 127
		write codeAt-int,		int-4
		write ushort! tflag,	int
		write byte! argc,		int+3
		write 0				// body size
		return codeAt
	parser.iGenerator.funcEnd, int, fname string
		write codeAt-int, int-4

//--------------------------------------------------------------------------------------------------

	//called after funcBody (after type and argument parsing)
	parser.iGenerator.func2prop int, int, pname string
		write byte! opcode.prop,int-5
		return int

	parser.iGenerator.propFieldStart int, int, pname string
		write byte! 0
		write 0				// size
		var at = codeAt
		return at
	parser.iGenerator.propFieldEnd, pm int, int, pname string
		write codeAt-int,		int-4

	parser.iGenerator.propFuncStart int, int, pname string, kind opcode
		write byte! (ushort! kind) >> 8
		write 0				// header size
		var at = codeAt
		write ushort! 0		// tflag
		return at
	parser.iGenerator.propFuncBody int, pm int, int, pname string, kind opcode, tflag
		write codeAt-int,		int-4
		write ushort! tflag,	int
		write 0				// body size
		return codeAt
	parser.iGenerator.propFuncEnd, pm int, int, pname string, kind opcode
		write codeAt-int, int-4

	parser.iGenerator.propEnd, int, pname string
		write codeAt-int, int-4
